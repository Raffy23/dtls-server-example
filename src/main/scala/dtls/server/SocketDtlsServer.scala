package dtls.server

import java.net._
import java.nio.ByteBuffer
import java.security.{KeyPair, SecureRandom}
import java.util.concurrent.atomic.AtomicBoolean
import java.util.concurrent.{ArrayBlockingQueue, ConcurrentHashMap, LinkedBlockingQueue, TimeUnit}

import dtls.util.codec.{Decoder, Encoder}
import org.bouncycastle.asn1.x509
import org.bouncycastle.tls._
import org.bouncycastle.tls.crypto.impl.bc.BcTlsCrypto

/**
 * A DTLS-Server implementation with Bouncycastle that provides similar characteristics to a
 * ServerSocket by encapsulating the conversation into a DTLSConnection and implementing an
 * accept method that returns these connections.
 *
 * The current implementation requires a X509 Certificate that is signed and uses an ECDSA key
 * generated by Bouncycastle.
 *
 * @author Raphael Ludwig
 * @version 08.08.20
 */
class SocketDtlsServer(bind: InetAddress, port: Int, certificate: x509.Certificate, masterKey: KeyPair, mtu: Int = 1500) extends AutoCloseable {
  import SocketDtlsServer._

  private val running  = new AtomicBoolean(true)

  /**
   * @return true if the server is running and able to process packets, false otherwise
   */
  def isRunning: Boolean = running.get()

  private implicit val crypto: BcTlsCrypto = new BcTlsCrypto(new SecureRandom())
  private val protocol = new DTLSServerProtocol()

  private val receiveSocket = new DatagramSocket(new InetSocketAddress(bind, port))

  // Needs more state keeping, all must be cleaned periodically
  private val connectStates  = new ConcurrentHashMap[SocketAddress, ConnectionState]()
  private val handshakes     = new ConcurrentHashMap[SocketAddress, (DTLSVerifier, Long)]
  private val newConnections = new ArrayBlockingQueue[NewConnection](16)

  // Thread that accepts all packets and puts them into their respective connection
  // data structures
  private val pktReceiver = new Thread(() => {
    val buffer = Array.ofDim[Byte](mtu)
    val packet = new DatagramPacket(buffer, mtu)
    var request: DTLSRequest = null

    while (running.get()) {

      receiveSocket.receive(packet)
      val address = packet.getSocketAddress

      // If there is a Connection, copy packet to the connection state
      val state = connectStates.get(address)
      if (state != null) {
        if (!state.packets.offer(Packet(packet.getData, packet.getLength))) {

          // Drop oldest packet if the queue is full
          state.packets.remove()
          state.packets.add(Packet(packet.getData, packet.getLength))
        }

      // Else assume new host, start handshake process
      } else {

        // New verifier for each host, no idea if they are threadsafe or not ...
        val timestamp = System.currentTimeMillis()
        val verifier  = handshakes.computeIfAbsent(address, _ => (new DTLSVerifier(crypto), timestamp))

        request = verifier._1.verifyRequest(
          packet.getAddress.getAddress,
          buffer,
          0,
          packet.getLength,
          new DatagramSender {
            override def getSendLimit: Int = mtu - MAX_IP_OVERHEAD - UDP_OVERHEAD
            override def send(buf: Array[Byte], off: Int, len: Int): Unit = {
              if (len > getSendLimit)
                throw new TlsFatalAlert(AlertDescription.internal_error)

              receiveSocket.send(new DatagramPacket(buf, off, len, address))
            }
          }
        )

        // If request has been generated add the connection to the list
        if (request != null) {
          handshakes.remove(packet.getSocketAddress)
          connectStates.put(packet.getSocketAddress, ConnectionState(packet.getSocketAddress))
          newConnections.add(NewConnection(packet.getSocketAddress, request))

          request = null
        }
      }
    }

  }, s"DTLS-Server ${new InetSocketAddress(bind, port)} (Packet Receiver)")
  pktReceiver.setDaemon(true)
  pktReceiver.start()

  /**
   * @return the number of pending handshakes, that the accept method has to process
   */
  def pendingHandshakes(): Int = newConnections.size()

  /**
   * Blocking call that waits for ned DTLSConnections and completes the handshake
   *
   * @throws InterruptedException when being interrupted while waiting for a new connection
   * @return a new DTLSConnection that is read to read/write data
   */
  @throws[InterruptedException]
  def accept(): DTLSConnection = {
    val newConnection = newConnections.take()
    val connection = new DTLSConnection(
      protocol.accept(
        server(masterKey, certificate),
        new UDPServerTransport(receiveSocket, connectStates.get(newConnection.address), mtu),
        newConnection.request
      ),
      newConnection.address
    )

    connection
  }

  /**
   * Closes the server socket, stops processing packets, all open connections can't be used afterwards
   * and can be left in an broken state if not closed explicitly
   */
  override def close(): Unit = {
    running.set(false)
    pktReceiver.interrupt()
  }

  /**
   * Per-Connection implementation of the DatagramTransport class that can use the single DatagramSocket
   * opened by the server, the semantics should be the same as from the UDPTransport implementation provided
   * by Bouncycastle
   *
   * @param socket the server socket that is used only to send DatagramPackets
   * @param state the internal connection state used to store the address and all received packages
   * @param mtu maximum transfer unit, ~508 bytes ca be considered safe
   */
  private class UDPServerTransport(socket: DatagramSocket, state: ConnectionState, mtu: Int) extends DatagramTransport {
    private val receiveLimit = mtu - MIN_IP_OVERHEAD - UDP_OVERHEAD
    private val sendLimit    = mtu - MAX_IP_OVERHEAD - UDP_OVERHEAD

    override def getReceiveLimit: Int = receiveLimit

    override def receive(buf: Array[Byte], off: Int, len: Int, waitMillis: Int): Int = {
      val pkt = state.packets.poll(waitMillis, TimeUnit.MILLISECONDS)

      if (pkt == null)
        return 0

      val copiedBytes = Math.min(pkt.bytes, len)
      System.arraycopy(pkt.data, 0, buf, off, copiedBytes)
      copiedBytes
    }

    override def close(): Unit = {
      connectStates.remove(state.address)

      state.closed.set(true)
      state.packets.clear()
    }

    override def getSendLimit: Int = sendLimit

    override def send(buf: Array[Byte], off: Int, len: Int): Unit = {
      socket.send(new DatagramPacket(buf, off, len, state.address))
    }
  }

}
object SocketDtlsServer {

  private case class NewConnection(address: SocketAddress, request: DTLSRequest)

  private case class ConnectionState(address: SocketAddress,
                                     packets: LinkedBlockingQueue[Packet] = new LinkedBlockingQueue[Packet](32),
                                     closed: AtomicBoolean = new AtomicBoolean(false))

  private case class Packet(data: Array[Byte], bytes: Int)

  /**
   * A Connection over UDP with the DTLS protocol. Since UDP is used this connection is unreliable.
   *
   * @param transport the underlying DTLSTransport implementation
   */
  class DTLSConnection protected[dtls](transport: DTLSTransport, val socketAddress: SocketAddress) extends AutoCloseable {

    /**
     * Sends the class provided over the socket to the other end. The encoder will automatically
     * encode the class into the packet representation
     *
     * @param packet a class that should be send over
     * @param encoder implicit encoder that encodes the class T
     * @tparam T class which should be encoded to a packet
     */
    def write[T](packet: T)(implicit encoder: Encoder[T]): Unit = {
      val data = encoder.encode(packet)
      transport.send(data.array(), 0, data.capacity())
    }

    /**
     * Waits for a packet that is automatically decoded by the provided decoder to the class T
     *
     * @param waitTime time in ms this call should block, 60s is the default value
     * @param decoder an implicit decoder for the class T
     * @tparam T class in which the packet should be decoded to
     * @throws RuntimeException if no byte where read from the socket
     * @return the decoded packet
     */
    @throws[RuntimeException]
    def read[T](waitTime: Int = 60_000)(implicit decoder: Decoder[T]): T = {
      val buffer = Array.ofDim[Byte](transport.getReceiveLimit)
      val read = transport.receive(buffer, 0, transport.getReceiveLimit, waitTime)
      if (read > 0)
        return decoder.decode(ByteBuffer.wrap(buffer))

      throw new RuntimeException("Buffer size is < 0")
    }

    /**
     * Closes the underlying transport connection, no further sending and receiving operations
     * are possible.
     */
    override def close(): Unit = transport.close()

  }

}